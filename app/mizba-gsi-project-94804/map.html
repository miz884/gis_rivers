<!DOCTYPE html>
<html>
  <head>
    <title>雨のゆき先マップ 関東編</title>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <style>
      html, body, #map-canvas {
        height: 100%;
        margin: 0px;
        padding: 0px
      }
      #title {
        padding: 3px;
        background: #fff;
        position: absolute;
        top: 0px;
        left: 0px;
        z-index: 100;
        font-family: sans-serif;
      }
      #title {
        max-width: 400px;
      }
      #title div,
      #title p {
        font-size: 8pt;
        padding: 0px;
        margin: 1px;
      }
      h1 {
        font-size: 15pt;
        padding: 0px;
        margin: 1px;
      }
    </style>
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp"></script>
    <script>

var DEBUG = false;
if (window && window.location && window.location.protocol == "file:") {
  DEBUG = true;
}

function debug(message) {
  if (!DEBUG) { 
    return;
  }
  console.log(message);
}

var E = 0.0001;
function f_equals(f1, f2) {
  return (Math.abs(f1 - f2) < E);
}


var map;
var marker;
var polygon;
var kml_layer;
var infowindow;

var GET_RIVER_SERVICE_URL =
    'http://mizba-gsi-project-94804.appspot.com/get_river?';
var GET_RIVER_MESH_SERVICE_URL =
    'http://mizba-gsi-project-94804.appspot.com/get_river_mesh?';
var KML_BASE_URL =
    'http://mizba-gsi-project-94804.appspot.com/kml/';

var MIN_LAT = 35.33333333568889;
var MIN_LNG = 139;
var MAX_LAT = 36.000000002385164;
var MAX_LNG = 140.00000000001108;

function initialize() {
  map = new google.maps.Map(document.getElementById('map-canvas'), {
    zoom: 8,
    center: new google.maps.LatLng((MIN_LAT+MAX_LAT)/2.0, (MIN_LNG+MAX_LNG)/2.0),
    mapTypeId: google.maps.MapTypeId.TERRAIN,
    zoomControlOptions: {
      position: google.maps.ControlPosition.RIGHT
    },
    panControlOptions: {
      position: google.maps.ControlPosition.RIGHT
    },
  });

  marker = new google.maps.Marker();
  kml_layer = new google.maps.KmlLayer({
    preserveViewport: true,
  });
  infowindow = new google.maps.InfoWindow();

  var targetArea = new google.maps.Rectangle({
    strokeColor: '#FF0000',
    strokeOpacity: 0.8,
    strokeWeight: 2,
    fillOpacity: 0.0,
    map: map,
    bounds: new google.maps.LatLngBounds(
      new google.maps.LatLng(MIN_LAT, MIN_LNG),
      new google.maps.LatLng(MAX_LAT, MAX_LNG))
  });
  google.maps.event.addListener(targetArea, 'click', function(click) {
    selectPoint(click.latLng);
    window.location.hash = click.latLng.lng() + '%7C' + click.latLng.lat();
  });
  map.fitBounds(targetArea.getBounds());

  if (window.location.hash) {
    var m = window.location.hash.substr(1).match(/^(\d*\.\d*)(\||%7C)(\d*\.\d*)$/);
    if (m) {
      selectPoint(new google.maps.LatLng(m[3], m[1]));
    }
  }
}


function loadScript(url) {
  var head = document.getElementsByTagName('head')[0];
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src = url;
  head.appendChild(script);
}

function selectPoint(latLng) {
  console.log("point: " + latLng);
  loadScript(GET_RIVER_SERVICE_URL +
      'lat=' + latLng.lat() + '&lng=' + latLng.lng() +
      '&callback=getRiverCB');
  marker.setPosition(latLng);
  marker.setMap(map);
  infowindow.close();
  if (polygon) {
    polygon.setMap(null);
  }
  kml_layer.setMap(null);
}

function getRiverCB(code, name, lng, lat, min_lng, min_lat, max_lng, max_lat) {
  console.log("river code: " + code);
  loadScript(GET_RIVER_MESH_SERVICE_URL +
      'code=' + code + '&callback=getRiverMeshCB');
  infowindow.setContent(name);
  infowindow.open(map, marker);
  kml_layer.setUrl(KML_BASE_URL + code + '.kml?'); //  + new Date().getTime());
  kml_layer.setMap(map);
}

var _SOUTH = 1;
var _WEST = 0;
var _NORTH = 3;
var _EAST = 2;

var _SW = 0;
var _SE = 1;
var _NE = 2;
var _NW = 3;

function getRiverMeshCB(mesh) {
  if (mesh.length == 0) {
    return;
  }

  // phase 1:
  // Merging squares horizontally if it's connecting each other.
  var rects = [];
  var r = mesh[0];
  for (var i = 1; i < mesh.length; ++i) {
    var p = mesh[i];
    if (f_equals(r[_SOUTH], p[_SOUTH]) && f_equals(r[_NORTH], p[_NORTH]) &&
        f_equals(r[_EAST], p[_WEST])) {
      r[_EAST] = p[_EAST];
    } else {
      rects.push([new google.maps.LatLng(r[_SOUTH], r[_WEST]),
          new google.maps.LatLng(r[_SOUTH], r[_EAST]),
          new google.maps.LatLng(r[_NORTH], r[_EAST]),
          new google.maps.LatLng(r[_NORTH], r[_WEST])]);
      r = p;
    }
  }
  rects.push([new google.maps.LatLng(r[_SOUTH], r[_WEST]),
      new google.maps.LatLng(r[_SOUTH], r[_EAST]),
      new google.maps.LatLng(r[_NORTH], r[_EAST]),
      new google.maps.LatLng(r[_NORTH], r[_WEST])]);
  debug("efficiency: " + rects.length + "/" + mesh.length + "=" +
      (rects.length / mesh.length));

  // showing border of rectangulars for debugging purpose.
  if (false && DEBUG) {
    for (i in rects) {
      var rect_opt = {
        strokeColor: '#00FF00',
        strokeWeight: 2.0,
        fillColor: '#00FF00',
        fillOpacity: 0.0,
        zIndex: 100,
        map: map,
        bounds: new google.maps.LatLngBounds(
          rects[i][_SW], rects[i][_NE])
      };
      var rect = new google.maps.Rectangle(rect_opt);
      google.maps.event.addListener(rect, 'click', function(){
        var ii = i;
        return function(click) {
        console.log(ii);
      };}());
    }
  }

  // phase 2:
  // Merging rectangulars vertically.
  var paths = [];
  var remainings = rects;
  for (var loop = 0; (loop < 10 && remainings.length > 0); ++loop) {
    debug("loop " + loop + " remainings " + remainings.length);
    var path = [];
    var prev = null;
    var targets = remainings;
    remainings = [];
    for (var i = 0; i < targets.length; ++i) {
      var curr = targets[i];
      if (prev) {
        if (!f_equals(prev[_NW].lat(), curr[_SW].lat()) &&
            prev[_NW].lat() < curr[_SW].lat()) {
          // if there is a gap between the previous and current rectangulars,
          // it means that the northen line of the previous rect does not
          // match to the southern line of the current rect,
          // enclose the current path and start a new path.
          if (path.length > 0) {
            path.push(path[0]);
            paths.push(path);
            path = [];
          }
        } else if (prev[_SE].lng() < curr[_SW].lng() ||
            prev[_SW].lng() > curr[_SE].lng() ||
            f_equals(prev[_SW].lat(), curr[_SW].lat())) {
          remainings.push(curr);
          continue;
        }
      }
      path.push(curr[_SE], curr[_NE]);
      path.splice(0, 0, curr[_NW], curr[_SW]);
      prev = curr;
    }
    if (path.length > 0) {
      path.push(path[0]);
      paths.push(path);
    }
  }
  for (var i in remainings) {
    var curr = remainings[i];
    paths.push(curr[_SW], curr[_SE], curr[_NE], curr[_NW], curr[_SW]);
  }
  debug("efficiency: " + paths.length + "/" + mesh.length + "=" +
      (paths.length / mesh.length));

  // rendering polygons
  var poly_opt = {
    strokeWeight: (DEBUG ? 1.0 : 0.0),
    fillColor: '#FF0000',
    fillOpacity: 0.35,
    map: map,
    paths: paths
  };
  polygon = new google.maps.Polygon(poly_opt);
}

google.maps.event.addDomListener(window, 'load', initialize);

    </script>
  </head>
  <body>
    <div id="title">
      <h1>雨のゆき先マップ 関東編</h1>
      <p><span>クリックした場所に降った雨が流れこむ川の名前、かたち、雨を集める範囲がわかります。
        表示まで5秒くらいかかります。</span></p>
      <p>このページは<a href="http://nlftp.mlit.go.jp/ksj/gml/datalist/KsjTmplt-W07.html">国土交通省の国土数値情 流域メッシュデータ</a> を利用しています。</p>
    </div>
    <div id="map-canvas"></div>
  </body>
</html>

